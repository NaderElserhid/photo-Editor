import React, { memo, useState, useRef, useEffect, useMemo } from 'react';

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise, SuppressedError, Symbol */

var extendStatics = function(d, b) {
  extendStatics = Object.setPrototypeOf ||
      ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
      function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
  return extendStatics(d, b);
};

function __extends(d, b) {
  if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
  extendStatics(d, b);
  function __() { this.constructor = d; }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = function() {
  __assign = Object.assign || function __assign(t) {
      for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
      }
      return t;
  };
  return __assign.apply(this, arguments);
};

function __rest(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
          if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
              t[p[i]] = s[p[i]];
      }
  return t;
}

function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
  return new (P || (P = Promise))(function (resolve, reject) {
      function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
      function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
      function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}

function __generator(thisArg, body) {
  var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
  function verb(n) { return function (v) { return step([n, v]); }; }
  function step(op) {
      if (f) throw new TypeError("Generator is already executing.");
      while (g && (g = 0, op[0] && (_ = 0)), _) try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
          if (y = 0, t) op = [op[0] & 2, t.value];
          switch (op[0]) {
              case 0: case 1: t = op; break;
              case 4: _.label++; return { value: op[1], done: false };
              case 5: _.label++; y = op[1]; op = [0]; continue;
              case 7: op = _.ops.pop(); _.trys.pop(); continue;
              default:
                  if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                  if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                  if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                  if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                  if (t[2]) _.ops.pop();
                  _.trys.pop(); continue;
          }
          op = body.call(thisArg, _);
      } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
      if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
  }
}

typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
  var e = new Error(message);
  return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};

var Remove$5 = "Quitar";
var Quality$5 = "Calidad";
var Format$5 = "Formato";
var Crop$5 = "Recortar";
var Save$5 = "Guardar";
var Contrast$5 = "Contraste";
var Blur$5 = "Blur";
var Brightness$5 = "Brillo";
var Grayscale$5 = "Scala de gris";
var Saturate$4 = "SaturaciÃ³n";
var Sepia$5 = "Sepia";
var Rotate$3 = "Rotar";
var Undo$5 = "Deshacer";
var Basic$5 = "BÃ¡sico";
var Filters$5 = "Filtros";
var labelEs = {
	"Upload a image": "Suba una imagen",
	"You must edit the image in order to resize it": "Debe editar la imagen para disminuir su tamaÃ±o",
	"too large": "muy grande",
	"Open the editor panel": "Abra el panel de ediciÃ³n",
	"Download the image": "Descarge la imagen",
	"Control Panel": "Panel de control",
	Remove: Remove$5,
	Quality: Quality$5,
	"Max dimensions": "Dimensiones",
	"aspect-ratio": "relaciÃ³n-aspecto",
	"max-width(px)": "max. ancho",
	"max-height(px)": "max. alto",
	Format: Format$5,
	Crop: Crop$5,
	"Confirm Crop": "Confirmar corte",
	"width(px)": "ancho(px)",
	"height(px)": "altura(px)",
	Save: Save$5,
	Contrast: Contrast$5,
	Blur: Blur$5,
	Brightness: Brightness$5,
	Grayscale: Grayscale$5,
	Saturate: Saturate$4,
	Sepia: Sepia$5,
	Rotate: Rotate$3,
	Undo: Undo$5,
	Basic: Basic$5,
	Filters: Filters$5
};

var Quality$4 = "Qualidade";
var Format$4 = "Formato";
var Crop$4 = "Cortar";
var Remove$4 = "Remover";
var Save$4 = "Salvar";
var Contrast$4 = "Contraste";
var Blur$4 = "Blur";
var Brightness$4 = "Brilho";
var Grayscale$4 = "Grayscale";
var Saturate$3 = "SaturaÃ§Ã£o";
var Sepia$4 = "Sepia";
var Rotate$2 = "Rotar";
var Undo$4 = "Desfazer";
var Basic$4 = "BÃ¡sico";
var Filters$4 = "Filtros";
var labelPT = {
	"Upload a image": "Carregar uma imagem",
	"You must edit the image in order to resize it": "VocÃª deve editar a imagem para redimensionÃ¡-la",
	"too large": "muito grande",
	"Open the editor panel": "Abra o painel do editor",
	"Download the image": "Baixe a imagem",
	"Control Panel": "Painel de controle",
	Quality: Quality$4,
	"Max dimensions": "DimensÃµes mÃ¡ximas",
	"aspect-ratio": "proporÃ§Ã£o da tela",
	"max-width(px)": "max-width(px)",
	"max-height(px)": "max-height(px)",
	Format: Format$4,
	Crop: Crop$4,
	"Confirm Crop": "Confirmar corte",
	"width(px)": "width(px)",
	"height(px)": "height(px)",
	Remove: Remove$4,
	Save: Save$4,
	Contrast: Contrast$4,
	Blur: Blur$4,
	Brightness: Brightness$4,
	Grayscale: Grayscale$4,
	Saturate: Saturate$3,
	Sepia: Sepia$4,
	Rotate: Rotate$2,
	Undo: Undo$4,
	Basic: Basic$4,
	Filters: Filters$4
};

var Quality$3 = "Quality";
var Format$3 = "Format";
var Crop$3 = "Crop";
var Remove$3 = "Remove";
var Save$3 = "Save";
var Contrast$3 = "Contrast";
var Blur$3 = "Blur";
var Brightness$3 = "Brightness";
var Grayscale$3 = "Grayscale";
var Saturate$2 = "Saturate";
var Sepia$3 = "Sepia";
var Rotate$1 = "Rotate";
var Undo$3 = "Undo";
var Basic$3 = "Basic";
var Filters$3 = "Filters";
var labelEn = {
	"Upload a image": "Upload a image",
	"You must edit the image in order to resize it": "You must edit the image in order to resize it",
	"too large": "too large",
	"Open the editor panel": "Open the editor panel",
	"Download the image": "Download the image",
	"Control Panel": "Control Panel",
	Quality: Quality$3,
	"Max dimensions": "Max dimensions",
	"aspect-ratio": "aspect-ratio",
	"max-width(px)": "max-width(px)",
	"max-height(px)": "max-height(px)",
	Format: Format$3,
	Crop: Crop$3,
	"Confirm Crop": "Confirm Crop",
	"width(px)": "width(px)",
	"height(px)": "height(px)",
	Remove: Remove$3,
	Save: Save$3,
	Contrast: Contrast$3,
	Blur: Blur$3,
	Brightness: Brightness$3,
	Grayscale: Grayscale$3,
	Saturate: Saturate$2,
	Sepia: Sepia$3,
	Rotate: Rotate$1,
	Undo: Undo$3,
	Basic: Basic$3,
	Filters: Filters$3
};

var Remove$2 = "Supprimer";
var Quality$2 = "QualitÃ©";
var Format$2 = "Format";
var Crop$2 = "Recadrer";
var Save$2 = "Sauvez";
var Contrast$2 = "Contraste";
var Blur$2 = "Blur";
var Brightness$2 = "LuminositÃ©";
var Grayscale$2 = "Grayscale";
var Saturate$1 = "Saturer";
var Sepia$2 = "Seiche";
var Undo$2 = "Annuler";
var Basic$2 = "Basique";
var Filters$2 = "Filtres";
var labelFr = {
	"Upload a image": "Charger une image",
	"You must edit the image in order to resize it": "Vous devez Ã©diter l'image pour changer sa taille",
	"too large": "Trop grande",
	"Open the editor panel": "Ouvrir le panneau d'Ã©dition",
	"Download the image": "TÃ©lÃ©charger l'image",
	"Control Panel": "Panneau de commande",
	Remove: Remove$2,
	Quality: Quality$2,
	"Max dimensions": "Dimensions maximales",
	"aspect-ratio": "rapport de forme",
	"max-width(px)": "largeur max.",
	"max-height(px)": "hauteur max",
	Format: Format$2,
	Crop: Crop$2,
	"Confirm Crop": "Confirmer le recadrage",
	"width(px)": "largeur(px)",
	"height(px)": "hauteur(px)",
	Save: Save$2,
	Contrast: Contrast$2,
	Blur: Blur$2,
	Brightness: Brightness$2,
	Grayscale: Grayscale$2,
	Saturate: Saturate$1,
	Sepia: Sepia$2,
	Undo: Undo$2,
	Basic: Basic$2,
	Filters: Filters$2
};

var Quality$1 = "QualitÃ¤t";
var Format$1 = "Format";
var Crop$1 = "Zuschneiden";
var Remove$1 = "Entfernen";
var Save$1 = "Speichern";
var Contrast$1 = "Kontrast";
var Blur$1 = "Blur";
var Brightness$1 = "Helligkeit";
var Grayscale$1 = "Graustufen";
var Saturer = "SÃ¤ttigen";
var Sepia$1 = "Tintenfisch";
var Undo$1 = "Undo";
var Basic$1 = "Einfach";
var Filters$1 = "Filter";
var labelDe = {
	"Upload a image": "Bild hochladen",
	"You must edit the image in order to resize it": "Sie mÃ¼ssen das Bild bearbeiten, um seine GrÃ¶ÃŸe zu Ã¤ndern",
	"too large": "zu groÃŸ",
	"Open the editor panel": "Editor-Fenster Ã¶ffnen",
	"Download the image": "Bild herunterladen",
	"Control Panel": "Bedienfeld",
	Quality: Quality$1,
	"Max dimensions": "Maximale GrÃ¶ÃŸe",
	"aspect-ratio": "SeitenverhÃ¤ltnis",
	"max-width(px)": "Max. Breite(px)",
	"max-height(px)": "Max. HÃ¶he(px)",
	Format: Format$1,
	Crop: Crop$1,
	"Confirm Crop": "Schnitt bestÃ¤tigen",
	"width(px)": "Breite(px)",
	"height(px)": "HÃ¶he(px)",
	Remove: Remove$1,
	Save: Save$1,
	Contrast: Contrast$1,
	Blur: Blur$1,
	Brightness: Brightness$1,
	Grayscale: Grayscale$1,
	Saturer: Saturer,
	Sepia: Sepia$1,
	Undo: Undo$1,
	Basic: Basic$1,
	Filters: Filters$1
};

var Quality = "Ú©ÛŒÙÛŒØª";
var Format = "ÙØ±Ù…Øª";
var Crop = "Ø¨Ø±Ø´";
var Remove = "Ø­Ø°Ù";
var Save = "Ø°Ø®ÛŒØ±Ù‡";
var Contrast = "Ú©Ù†ØªØ±Ø§Ø³Øª";
var Blur = "Ù…Ø­Ùˆ";
var Brightness = "Ø±ÙˆØ´Ù†Ø§ÛŒÛŒ";
var Grayscale = "Ø®Ø§Ú©Ø³ØªØ±ÛŒ";
var Saturate = "Ø§Ø´Ø¨Ø§Ø¹";
var Sepia = "Sepia";
var Rotate = "Ú†Ø±Ø®Ø´";
var Undo = "Ø¨Ø±Ú¯Ø´Øª";
var Basic = "Ù¾Ø§ÛŒÙ‡";
var Filters = "ÙÛŒÙ„ØªØ± Ù‡Ø§";
var labelFa = {
	"Upload a image": "Ø¢Ù¾Ù„ÙˆØ¯ ØªØµÙˆÛŒØ±",
	"You must edit the image in order to resize it": "Ø¨Ø±Ø§ÛŒ ØªØºÛŒÛŒØ± Ø§Ù†Ø¯Ø§Ø²Ù‡ ØªØµÙˆÛŒØ± Ø¨Ø§ÛŒØ¯ Ø¢Ù† Ø±Ø§ ÙˆÛŒØ±Ø§ÛŒØ´ Ú©Ù†ÛŒØ¯",
	"too large": "Ø¨Ø³ÛŒØ§Ø± Ø¨Ø²Ø±Ú¯",
	"Open the editor panel": "Ù¾Ù†Ù„ ÙˆÛŒØ±Ø§ÛŒØ´",
	"Download the image": "Ø¯Ø§Ù†Ù„ÙˆØ¯ ØªØµÙˆÛŒØ±",
	"Control Panel": "Ù¾Ù†Ù„ Ú©Ù†ØªØ±Ù„",
	Quality: Quality,
	"Max dimensions": "Ø­Ø¯Ø§Ú©Ø«Ø± Ø§Ø¨Ø¹Ø§Ø¯",
	"aspect-ratio": "Ù†Ø³Ø¨Øª Ø§Ù†Ø¯Ø§Ø²Ù‡",
	"max-width(px)": "Ø­Ø¯Ø§Ú©Ø«Ø± Ø·ÙˆÙ„ (px)",
	"max-height(px)": "Ø­Ø¯Ø§Ú©Ø«Ø± Ø§Ø±ØªÙØ§Ø¹ (px)",
	Format: Format,
	Crop: Crop,
	"Confirm Crop": "ØªØ§ÛŒÛŒØ¯ Ø¨Ø±Ø´",
	"width(px)": "Ø·ÙˆÙ„ (px)",
	"height(px)": "Ø§Ø±ØªÙØ§Ø¹ (px)",
	Remove: Remove,
	Save: Save,
	Contrast: Contrast,
	Blur: Blur,
	Brightness: Brightness,
	Grayscale: Grayscale,
	Saturate: Saturate,
	Sepia: Sepia,
	Rotate: Rotate,
	Undo: Undo,
	Basic: Basic,
	Filters: Filters
};

var MAX_BUFFER_UNDO_MEMORY = 25;
var convertImageUsingCanvas = function (dataSrc, changeHeight, state, options) {
    if (changeHeight === void 0) { changeHeight = false; }
    return new Promise(function (resolve, _) { return __awaiter(void 0, void 0, void 0, function () {
        var img, quality, maintainRatio;
        return __generator(this, function (_a) {
            img = document.createElement('img');
            img.src = dataSrc + '';
            img.crossOrigin = 'Anonymous';
            quality = state.quality / 100;
            maintainRatio = state.maintainAspectRatio;
            img.onload = function () {
                var canvas = document.createElement('canvas');
                var ctx = canvas.getContext('2d');
                var ratio = img.width / img.height;
                var width = state.maxWidth;
                var height = state.maxHeight;
                if (options === null || options === void 0 ? void 0 : options.getDimFromImage) {
                    width = img.width;
                    height = img.height;
                }
                if (maintainRatio) {
                    canvas.width = width;
                    canvas.height = width / ratio;
                    if (changeHeight) {
                        canvas.width = height * ratio;
                        canvas.height = height;
                    }
                }
                else {
                    canvas.width = width;
                    canvas.height = height;
                }
                if (state.basicFilters) {
                    ctx.filter = processFilter(state.basicFilters);
                }
                ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                var type = state.format;
                var dataURI = canvas.toDataURL("image/".concat(type), quality);
                // console.log("ðŸš€ ~ file: image-processing.ts ~ line 48 ~ returnnewPromise ~ quality", quality)
                resolve({
                    dataUri: dataURI,
                    width: canvas.width,
                    height: canvas.height
                });
            };
            return [2 /*return*/];
        });
    }); }).then(function (data) {
        state.maxHeight = data.height;
        state.maxWidth = data.width;
        return { imageUri: data.dataUri, state: saveState(state, data.dataUri) };
    });
    function processFilter(data) {
        return Object.keys(data)
            .map(function (key) {
            if (['blur'].includes(key)) {
                return "".concat(key, "(").concat(data[key], "px)");
            }
            else {
                return "".concat(key, "(").concat(data[key], ")");
            }
        })
            .join('');
    }
};
var saveState = function (state, lastImage) {
    if (state.arrayCopiedImages.length <= MAX_BUFFER_UNDO_MEMORY) {
        state.arrayCopiedImages.push({
            lastImage: lastImage,
            width: state.maxWidth,
            height: state.maxHeight,
            quality: state.quality,
            format: state.format,
            originImageSrc: state.originImageSrc,
            basicFilters: state.basicFilters
        });
    }
    else {
        state.arrayCopiedImages[state.arrayCopiedImages.length - 1] = {
            lastImage: lastImage,
            width: state.maxWidth,
            height: state.maxHeight,
            quality: state.quality,
            format: state.format,
            originImageSrc: state.originImageSrc,
            basicFilters: state.basicFilters
        };
    }
    return JSON.parse(JSON.stringify(state));
};

/* eslint-disable react-hooks/exhaustive-deps */
var TabContainer = memo(function (_a) {
    var _b = _a.activeIndex, activeIndex = _b === void 0 ? 0 : _b, children = _a.children, _c = _a.backgroundColor, backgroundColor = _c === void 0 ? 'inherit' : _c, _d = _a.color, color = _d === void 0 ? '#428CFF' : _d, _e = _a.indicatorStyle, indicatorStyle = _e === void 0 ? 'bottomLine' : _e, _f = _a.onTabChange, onTabChange = _f === void 0 ? function (index) { } : _f, _g = _a.transitionMs, transitionMs = _g === void 0 ? 375 : _g, _h = _a.borderLine, borderLine = _h === void 0 ? false : _h, _j = _a.fontColor, fontColor = _j === void 0 ? 'inherit' : _j, _k = _a.lazy, lazy = _k === void 0 ? false : _k;
    var _l = useState([]), header = _l[0], setHeader = _l[1];
    var _m = useState(activeIndex), activeTab = _m[0], setActiveTab = _m[1];
    var tabContainerRef = useRef(null);
    useEffect(function () {
        var tabsItems = children instanceof Array ? children : [children];
        checkChildrens(tabsItems);
        var tabs = tabsItems.map(function (el) { return ({ label: el.props.name, icon: el.props.icon, disabled: el.props.disabled }); });
        if (activeIndex > tabs.length - 1 || activeIndex < 0)
            throw new Error("Invalid range for activeIndex ".concat(activeIndex));
        setHeader(tabs);
    }, [children]);
    useEffect(function () {
        var _a, _b;
        var tabsItems = children instanceof Array ? children : [children];
        if (activeIndex > tabsItems.length - 1 || activeIndex < 0)
            throw new Error("Invalid range for activeIndex ".concat(activeIndex));
        setActiveTab(((_b = (_a = tabsItems[activeIndex]) === null || _a === void 0 ? void 0 : _a.props) === null || _b === void 0 ? void 0 : _b.disabled) ? 0 : activeIndex);
    }, [activeIndex]);
    useEffect(function () {
        if (header && header.length) {
            onTabChange(activeTab);
        }
    }, [activeTab]);
    function checkChildrens(data) {
        try {
            data.map(function (el) {
                if (!el.props.name)
                    throw new Error('Inside of TabContainer component only can be rendered TabItem component, and its need a name prop');
                return true;
            });
        }
        catch (e) {
            throw new Error("The TabContainer Component must has a TabItem as child component");
        }
    }
    var tabsItems = children instanceof Array ? children : [children];
    return React.createElement("div", { ref: tabContainerRef, className: "tab-pp" },
        React.createElement("div", { className: "header", style: { backgroundColor: backgroundColor, borderBottom: borderLine ? '1px solid #323232' : 'undet' } }, header.map(function (el, index) { return (React.createElement("button", { onClick: function () {
                if (el.disabled)
                    return;
                setActiveTab(index);
            }, key: el.label, style: {
                color: index == activeTab && (indicatorStyle === 'simple' || indicatorStyle === 'bottomLine') ? color : fontColor,
                backgroundColor: index == activeTab && (indicatorStyle === 'button') ? color : 'inherit'
            }, className: index == activeTab ? "itemlabel ".concat(indicatorStyle, " active") : 'itemlabel', disabled: el.disabled },
            el.icon,
            " ",
            el.label,
            indicatorStyle === 'bottomLine' && (React.createElement("div", { style: { backgroundColor: color } })))); })),
        React.createElement("div", { className: "body" }, tabsItems.map(function (tabEl, index) {
            if (index < activeTab) {
                return (React.createElement("div", { style: {
                        transform: 'translate3d(-100%, 0px, 0px)',
                        height: '0px',
                        overflow: 'hidden',
                        transition: "transform ".concat(transitionMs / 1000, "s ease")
                    }, key: index, className: 'body-content' }, !lazy && tabEl));
            }
            if (index > activeTab) {
                return (React.createElement("div", { style: {
                        transform: 'translate3d(100%, 0px, 0px)',
                        height: '0px',
                        overflow: 'hidden',
                        transition: "transform ".concat(transitionMs / 1000, "s ease")
                    }, key: index, className: 'body-content' }, !lazy && tabEl));
            }
            else {
                return (React.createElement("div", { style: {
                        visibility: 'inherit',
                        overflow: 'auto',
                        height: 'auto',
                        position: 'relative',
                        transition: "transform ".concat(transitionMs / 1000, "s ease")
                    }, key: index, className: 'body-content' }, tabEl));
            }
        })));
});
var TabItem = memo(function (_a) {
    _a.name; var children = _a.children; _a.icon; _a.type; _a.disabled;
    return React.createElement("div", { style: { padding: '1rem 0.5rem' } }, children);
});

var Input = memo(function (props) {
    var _a = props, onInputChangedEnd = _a.onInputChangedEnd, onChangedDelayed = _a.onChangedDelayed, onChangedValue = _a.onChangedValue, delayMs = _a.delayMs, restProps = __rest(_a, ["onInputChangedEnd", "onChangedDelayed", "onChangedValue", "delayMs"]);
    var _b = useState(props.value), state = _b[0], setState = _b[1];
    var timerRef = useRef();
    var mountRef = useRef(true);
    useRef(false);
    // useEffect(() => {
    //   if (['checkbox', 'radio'].includes(props.type as string)) {
    //     setState(props.checked);
    //   } else {
    //     setState(props.value);
    //     console.log("Here in the prop")
    //   }
    // }, [props.value])
    useEffect(function () {
        if (!onChangedDelayed)
            return;
        if (mountRef.current) {
            mountRef.current = false;
            return;
        }
        clearTimeout(timerRef.current);
        timerRef.current = setTimeout(function () {
            clearTimeout(timerRef.current);
            onChangedDelayed(state);
        }, delayMs || 100);
        return function () {
            clearTimeout(timerRef.current);
        };
    }, [state]);
    function changeValue(e) {
        if (['checkbox', 'radio'].includes(props.type)) {
            setState(e.target.checked);
            onChangedValue && onChangedValue(e.target.checked);
        }
        else {
            setState(e.target.value);
            onChangedValue && onChangedValue(e.target.value);
        }
    }
    return (React.createElement(React.Fragment, null,
        onInputChangedEnd && React.createElement("input", __assign({}, restProps, { className: restProps === null || restProps === void 0 ? void 0 : restProps.className, style: restProps.style, value: props.value, onChange: changeValue, onBlur: function (e) { onInputChangedEnd(e.target.value); }, onKeyDown: function (e) {
                if (e.key == 'Enter')
                    onInputChangedEnd(state);
            } })),
        !onInputChangedEnd && React.createElement("input", __assign({}, restProps, { className: restProps === null || restProps === void 0 ? void 0 : restProps.className, style: restProps.style, value: props.value, onChange: changeValue }))));
});

var _initialState$1 = {
    contrast: 1,
    blur: 0,
    brightness: 1,
    grayscale: 0,
    invert: 0,
    saturate: 1,
    sepia: 0
};
var BasicFilter = memo(function (_a) {
    var labels = _a.labels, color = _a.color, _b = _a.initialState, initialState = _b === void 0 ? _initialState$1 : _b, _c = _a.changeFilter, changeFilter = _c === void 0 ? function () { } : _c;
    var _d = useState(initialState), state = _d[0], setState = _d[1];
    useEffect(function () {
        if (initialState) {
            setState(JSON.parse(JSON.stringify(__assign(__assign({}, state), initialState))));
        }
        else {
            setState(_initialState$1);
        }
    }, [initialState]);
    function onUpdateContrast(contrast) {
        changeFilter(__assign(__assign({}, state), { contrast: contrast }));
    }
    function onUpdateBrightness(brightness) {
        changeFilter(__assign(__assign({}, state), { brightness: brightness }));
    }
    function onUpdateGrayscale(grayscale) {
        changeFilter(__assign(__assign({}, state), { grayscale: grayscale }));
    }
    function onUpdateSaturate(saturate) {
        changeFilter(__assign(__assign({}, state), { saturate: saturate }));
    }
    function onUpdateSepia(sepia) {
        changeFilter(__assign(__assign({}, state), { sepia: sepia }));
    }
    function onUpdateBlur(blur) {
        changeFilter(__assign(__assign({}, state), { blur: blur }));
    }
    return React.createElement("div", null,
        React.createElement("div", { style: { display: 'flex', width: '100%', justifyContent: 'space-between' } },
            React.createElement("p", { className: "item-panel" }, labels['Contrast']),
            React.createElement("p", { className: "item-panel" }, (+state.contrast).toFixed(2))),
        React.createElement("div", { className: 'flex-row-start' },
            React.createElement(Input, { className: "input-range", onChangedDelayed: onUpdateContrast, delayMs: 100, onChangedValue: function (value) { setState(__assign(__assign({}, state), { contrast: value })); }, style: {
                    maxWidth: '100%', width: '100%', color: color
                }, type: "range", min: "0", max: "5", step: "0.01", value: state.contrast })),
        React.createElement("div", { style: { display: 'flex', width: '100%', justifyContent: 'space-between' } },
            React.createElement("p", { className: "item-panel" }, labels['Brightness']),
            React.createElement("p", { className: "item-panel" }, (+state.brightness).toFixed(2))),
        React.createElement("div", { className: 'flex-row-start' },
            React.createElement(Input, { className: "input-range", onChangedDelayed: onUpdateBrightness, onChangedValue: function (value) { setState(__assign(__assign({}, state), { brightness: value })); }, style: {
                    maxWidth: '100%', width: '100%', color: color
                }, type: "range", min: "0", max: "5", step: "0.01", value: state.brightness })),
        React.createElement("div", { style: { display: 'flex', width: '100%', justifyContent: 'space-between' } },
            React.createElement("p", { className: "item-panel" }, labels['Grayscale']),
            React.createElement("p", { className: "item-panel" }, (+state.grayscale).toFixed(2))),
        React.createElement("div", { className: 'flex-row-start' },
            React.createElement(Input, { className: "input-range", onChangedDelayed: onUpdateGrayscale, onChangedValue: function (value) { setState(__assign(__assign({}, state), { grayscale: value })); }, style: {
                    maxWidth: '100%', width: '100%', color: color
                }, type: "range", min: "0", max: "5", step: "0.01", value: state.grayscale })),
        React.createElement("div", { style: { display: 'flex', width: '100%', justifyContent: 'space-between' } },
            React.createElement("p", { className: "item-panel" }, labels['Saturate']),
            React.createElement("p", { className: "item-panel" }, (+state.saturate).toFixed(2))),
        React.createElement("div", { className: 'flex-row-start' },
            React.createElement(Input, { className: "input-range", onChangedDelayed: onUpdateSaturate, onChangedValue: function (value) { setState(__assign(__assign({}, state), { saturate: value })); }, style: {
                    maxWidth: '100%', width: '100%', color: color
                }, type: "range", min: "0", max: "5", step: "0.01", value: state.saturate })),
        React.createElement("div", { style: { display: 'flex', width: '100%', justifyContent: 'space-between' } },
            React.createElement("p", { className: "item-panel" }, labels['Sepia']),
            React.createElement("p", { className: "item-panel" }, (+state.sepia).toFixed(2))),
        React.createElement("div", { className: 'flex-row-start' },
            React.createElement(Input, { className: "input-range", onChangedDelayed: onUpdateSepia, onChangedValue: function (value) { setState(__assign(__assign({}, state), { sepia: value })); }, style: {
                    maxWidth: '100%', width: '100%', color: color
                }, type: "range", min: "0", max: "5", step: "0.01", value: state.sepia })),
        React.createElement("div", { style: { display: 'flex', width: '100%', justifyContent: 'space-between' } },
            React.createElement("p", { className: "item-panel" }, labels['Blur']),
            React.createElement("p", { className: "item-panel" }, (+state.blur).toFixed(2))),
        React.createElement("div", { className: 'flex-row-start' },
            React.createElement(Input, { className: "input-range", onChangedDelayed: onUpdateBlur, onChangedValue: function (value) { setState(__assign(__assign({}, state), { blur: value })); }, style: {
                    maxWidth: '100%', width: '100%', color: color
                }, type: "range", min: "0", max: "5", step: "0.01", value: state.blur })));
});

/**
 * POLYFILLS
 */
// Request Animation Frame polyfill
(function () {
    var lastTime = 0;
    var vendors = ["ms", "moz", "webkit", "o"];
    for (var x = 0; x < vendors.length && !window.requestAnimationFrame; x++) {
        window.requestAnimationFrame = window[(vendors[x] + "RequestAnimationFrame")];
        window.cancelAnimationFrame = (window[(vendors[x] + "CancelAnimationFrame")] || window[(vendors[x] + "CancelRequestAnimationFrame")]);
    }
    if (!window.requestAnimationFrame)
        window.requestAnimationFrame = function (callback, element) {
            var currTime = new Date().getTime();
            var timeToCall = Math.max(0, 16 - (currTime - lastTime));
            var id = window.setTimeout(function () {
                callback(currTime + timeToCall);
            }, timeToCall);
            lastTime = currTime + timeToCall;
            return id;
        };
    if (!window.cancelAnimationFrame)
        window.cancelAnimationFrame = function (id) {
            clearTimeout(id);
        };
})();
// CustomEvents polyfill
(function () {
    if (typeof window.CustomEvent === "function")
        return false;
    function CustomEvent(event, params) {
        params = params || { bubbles: false, cancelable: false, detail: undefined };
        var evt = document.createEvent("CustomEvent");
        evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);
        return evt;
    }
    CustomEvent.prototype = window.Event.prototype;
    window.CustomEvent = CustomEvent;
})();
// MouseEvents polyfill
(function (window) {
    try {
        new CustomEvent("test");
        return false; // No need to polyfill
    }
    catch (e) {
        // Need to polyfill - fall through
    }
    // Polyfills DOM4 CustomEvent
    function MouseEvent(eventType, params) {
        params = params || { bubbles: false, cancelable: false };
        var mouseEvent = document.createEvent("MouseEvent");
        mouseEvent.initMouseEvent(eventType, params.bubbles, params.cancelable, window, 0, 0, 0, 0, 0, false, false, false, false, 0, null);
        return mouseEvent;
    }
    MouseEvent.prototype = Event.prototype;
    window.MouseEvent = MouseEvent;
})(window);

/**
 * Handle component
 */
var Handle = /** @class */ (function () {
    function Handle(position, constraints, cursor, eventBus) {
        var self = this;
        this.position = position;
        this.constraints = constraints;
        this.cursor = cursor;
        this.eventBus = eventBus;
        // Create DOM element
        this.el = document.createElement("div");
        this.el.className = "croppr-handle";
        this.el.style.cursor = cursor;
        // Attach initial listener
        this.el.addEventListener("mousedown", onMouseDown);
        function onMouseDown(e) {
            e.stopPropagation();
            document.addEventListener("mouseup", onMouseUp);
            document.addEventListener("mousemove", onMouseMove);
            // Notify parent
            self.eventBus.dispatchEvent(new CustomEvent("handlestart", {
                detail: { handle: self }
            }));
        }
        function onMouseUp(e) {
            e.stopPropagation();
            document.removeEventListener("mouseup", onMouseUp);
            document.removeEventListener("mousemove", onMouseMove);
            // Notify parent
            self.eventBus.dispatchEvent(new CustomEvent("handleend", {
                detail: { handle: self }
            }));
        }
        function onMouseMove(e) {
            e.stopPropagation();
            // Notify parent
            self.eventBus.dispatchEvent(new CustomEvent("handlemove", {
                detail: { mouseX: e.clientX, mouseY: e.clientY }
            }));
        }
    }
    return Handle;
}());

/**
 * Box component
 */
var Box = /** @class */ (function () {
    function Box(x1, y1, x2, y2) {
        this.x1 = x1;
        this.y1 = y1;
        this.x2 = x2;
        this.y2 = y2;
    }
    /**
     * Sets the new dimensions of the box.
     * @param {Number} x1
     * @param {Number} y1
     * @param {Number} x2
     * @param {Number} y2
     */
    Box.prototype.set = function (x1, y1, x2, y2) {
        if (x1 === void 0) { x1 = null; }
        if (y1 === void 0) { y1 = null; }
        if (x2 === void 0) { x2 = null; }
        if (y2 === void 0) { y2 = null; }
        this.x1 = x1 == null ? this.x1 : x1;
        this.y1 = y1 == null ? this.y1 : y1;
        this.x2 = x2 == null ? this.x2 : x2;
        this.y2 = y2 == null ? this.y2 : y2;
        return this;
    };
    /**
     * Calculates the width of the box.
     * @returns {Number}
     */
    Box.prototype.width = function () {
        return Math.abs(this.x2 - this.x1);
    };
    /**
     * Calculates the height of the box.
     * @returns {Number}
     */
    Box.prototype.height = function () {
        return Math.abs(this.y2 - this.y1);
    };
    /**
     * Resizes the box to a new size.
     * @param {Number} newWidth
     * @param {Number} newHeight
     * @param {Array} [origin] The origin point to resize from.
     *      Defaults to [0, 0] (top left).
     */
    Box.prototype.resize = function (newWidth, newHeight, origin) {
        if (origin === void 0) { origin = [0, 0]; }
        var fromX = this.x1 + this.width() * origin[0];
        var fromY = this.y1 + this.height() * origin[1];
        this.x1 = fromX - newWidth * origin[0];
        this.y1 = fromY - newHeight * origin[1];
        this.x2 = this.x1 + newWidth;
        this.y2 = this.y1 + newHeight;
        return this;
    };
    /**
     * Scale the box by a factor.
     * @param {Number} factor
     * @param {Array} [origin] The origin point to resize from.
     *      Defaults to [0, 0] (top left).
     */
    Box.prototype.scale = function (factor, origin) {
        if (origin === void 0) { origin = [0, 0]; }
        var newWidth = this.width() * factor;
        var newHeight = this.height() * factor;
        this.resize(newWidth, newHeight, origin);
        return this;
    };
    /**
     * Move the box to the specified coordinates.
     */
    Box.prototype.move = function (x, y) {
        if (x === void 0) { x = null; }
        if (y === void 0) { y = null; }
        var width = this.width();
        var height = this.height();
        x = x === null ? this.x1 : x;
        y = y === null ? this.y1 : y;
        this.x1 = x;
        this.y1 = y;
        this.x2 = x + width;
        this.y2 = y + height;
        return this;
    };
    /**
     * Get relative x and y coordinates of a given point within the box.
     * @param {Array} point The x and y ratio position within the box.
     * @returns {Array} The x and y coordinates [x, y].
     */
    Box.prototype.getRelativePoint = function (point) {
        if (point === void 0) { point = [0, 0]; }
        var x = this.width() * point[0];
        var y = this.height() * point[1];
        return [x, y];
    };
    /**
     * Get absolute x and y coordinates of a given point within the box.
     * @param {Array} point The x and y ratio position within the box.
     * @returns {Array} The x and y coordinates [x, y].
     */
    Box.prototype.getAbsolutePoint = function (point) {
        if (point === void 0) { point = [0, 0]; }
        var x = this.x1 + this.width() * point[0];
        var y = this.y1 + this.height() * point[1];
        return [x, y];
    };
    /**
     * Constrain the box to a fixed ratio.
     * @param {Number} ratio
     * @param {Array} [origin] The origin point to resize from.
     *     Defaults to [0, 0] (top left).
     * @param {String} [grow] The axis to grow to maintain the ratio.
     *     Defaults to 'height'.
     */
    Box.prototype.constrainToRatio = function (ratio, origin, grow) {
        if (origin === void 0) { origin = [0, 0]; }
        if (grow === void 0) { grow = "height"; }
        if (ratio === null) {
            return;
        }
        this.width();
        this.height();
        switch (grow) {
            case "height": // Grow height only
                this.resize(this.width(), this.width() * ratio, origin);
                break;
            case "width": // Grow width only
                this.resize((this.height() * 1) / ratio, this.height(), origin);
                break;
            default: // Default: Grow height only
                this.resize(this.width(), this.width() * ratio, origin);
        }
        return this;
    };
    /**
     * Constrain the box within a boundary.
     * @param {Number} boundaryWidth
     * @param {Number} boundaryHeight
     * @param {Array} [origin] The origin point to resize from.
     *     Defaults to [0, 0] (top left).
     */
    Box.prototype.constrainToBoundary = function (boundaryWidth, boundaryHeight, origin) {
        if (origin === void 0) { origin = [0, 0]; }
        // Calculate the maximum sizes for each direction of growth
        var _a = this.getAbsolutePoint(origin), originX = _a[0], originY = _a[1];
        var maxIfLeft = originX;
        var maxIfTop = originY;
        var maxIfRight = boundaryWidth - originX;
        var maxIfBottom = boundaryHeight - originY;
        // Express the direction of growth in terms of left, both,
        // and right as -1, 0, and 1 respectively. Ditto for top/both/down.
        var directionX = -2 * origin[0] + 1;
        var directionY = -2 * origin[1] + 1;
        // Determine the max size to use according to the direction of growth.
        var _b = [null, null], maxWidth = _b[0], maxHeight = _b[1];
        switch (directionX) {
            case -1:
                maxWidth = maxIfLeft;
                break;
            case 0:
                maxWidth = (Math.min(maxIfLeft, maxIfRight) * 2);
                break;
            case +1:
                maxWidth = maxIfRight;
                break;
        }
        switch (directionY) {
            case -1:
                maxHeight = maxIfTop;
                break;
            case 0:
                maxHeight = (Math.min(maxIfTop, maxIfBottom) * 2);
                break;
            case +1:
                maxHeight = maxIfBottom;
                break;
        }
        // Resize if the box exceeds the calculated max width/height.
        if (this.width() > maxWidth) {
            var factor = maxWidth / this.width();
            this.scale(factor, origin);
        }
        if (this.height() > maxHeight) {
            var factor = maxHeight / this.height();
            this.scale(factor, origin);
        }
        return this;
    };
    /**
     * Constrain the box to a maximum/minimum size.
     * @param {Number} [maxWidth]
     * @param {Number} [maxHeight]
     * @param {Number} [minWidth]
     * @param {Number} [minHeight]
     * @param {Array} [origin] The origin point to resize from.
     *     Defaults to [0, 0] (top left).
     * @param {Number} [ratio] Ratio to maintain.
     */
    Box.prototype.constrainToSize = function (maxWidth, maxHeight, minWidth, minHeight, origin, ratio) {
        if (maxWidth === void 0) { maxWidth = null; }
        if (maxHeight === void 0) { maxHeight = null; }
        if (minWidth === void 0) { minWidth = null; }
        if (minHeight === void 0) { minHeight = null; }
        if (origin === void 0) { origin = [0, 0]; }
        if (ratio === void 0) { ratio = null; }
        // Calculate new max/min widths & heights that constrains to the ratio
        if (ratio) {
            if (ratio > 1) {
                maxWidth = (maxHeight * 1) / ratio;
                minHeight = minHeight * ratio;
            }
            else if (ratio < 1) {
                maxHeight = maxWidth * ratio;
                minWidth = (minHeight * 1) / ratio;
            }
        }
        if (maxWidth && this.width() > maxWidth) {
            var newWidth = maxWidth, newHeight = ratio === null ? this.height() : maxHeight;
            this.resize(newWidth, newHeight, origin);
        }
        if (maxHeight && this.height() > maxHeight) {
            var newWidth = ratio === null ? this.width() : maxWidth, newHeight = maxHeight;
            this.resize(newWidth, newHeight, origin);
        }
        if (minWidth && this.width() < minWidth) {
            var newWidth = minWidth, newHeight = ratio === null ? this.height() : minHeight;
            this.resize(newWidth, newHeight, origin);
        }
        if (minHeight && this.height() < minHeight) {
            var newWidth = ratio === null ? this.width() : minWidth, newHeight = minHeight;
            this.resize(newWidth, newHeight, origin);
        }
        return this;
    };
    return Box;
}());

/**
 * Croppr Touch
 * Enables support for touch devices by translating touch events to
 * mouse events.
 */
/**
 * Binds an element's touch events to be simulated as mouse events.
 * @param {Element} element
 */
function enableTouch(element) {
    element.addEventListener('touchstart', simulateMouseEvent);
    element.addEventListener('touchend', simulateMouseEvent);
    element.addEventListener('touchmove', simulateMouseEvent);
}
/**
 * Translates a touch event to a mouse event.
 * @param {Event} e
 */
function simulateMouseEvent(e) {
    e.preventDefault();
    var touch = e.changedTouches[0];
    var eventMap = {
        touchstart: 'mousedown',
        touchmove: 'mousemove',
        touchend: 'mouseup'
    };
    touch.target.dispatchEvent(new MouseEvent(eventMap[e.type], {
        bubbles: true,
        cancelable: true,
        view: window,
        clientX: touch.clientX,
        clientY: touch.clientY,
        screenX: touch.screenX,
        screenY: touch.screenY
    }));
}

/**
 * CropprCore
 * Here lies the main logic.
 */
/**
 * Define a list of handles to create.
 *
 * @property {Array} position - The x and y ratio position of the handle within
 *      the crop region. Accepts a value between 0 to 1 in the order of [X, Y].
 * @property {Array} constraints - Define the side of the crop region that is to
 *      be affected by this handle. Accepts a value of 0 or 1 in the order of
 *      [TOP, RIGHT, BOTTOM, LEFT].
 * @property {String} cursor - The CSS cursor of this handle.
 */
var HANDLES = [
    { position: [0.0, 0.0], constraints: [1, 0, 0, 1], cursor: "nw-resize" },
    { position: [0.5, 0.0], constraints: [1, 0, 0, 0], cursor: "n-resize" },
    { position: [1.0, 0.0], constraints: [1, 1, 0, 0], cursor: "ne-resize" },
    { position: [1.0, 0.5], constraints: [0, 1, 0, 0], cursor: "e-resize" },
    { position: [1.0, 1.0], constraints: [0, 1, 1, 0], cursor: "se-resize" },
    { position: [0.5, 1.0], constraints: [0, 0, 1, 0], cursor: "s-resize" },
    { position: [0.0, 1.0], constraints: [0, 0, 1, 1], cursor: "sw-resize" },
    { position: [0.0, 0.5], constraints: [0, 0, 0, 1], cursor: "w-resize" },
];
/**
 * Core class for Croppr containing most of its functional logic.
 */
var CropprCore = /** @class */ (function () {
    function CropprCore(element, options, deferred) {
        if (deferred === void 0) { deferred = false; }
        var _this = this;
        // console.log("ðŸš€ ~ file: core.ts ~ line 51 ~ CropprCore ~ constructor ~ element", element)
        // Parse options
        this.options = CropprCore.parseOptions(options || {});
        // Get target img element
        if (!element.nodeName) {
            element = document.querySelector(element);
            // console.log("ðŸš€ ~ file: core.ts ~ line 58 ~ CropprCore ~ constructor ~ element", element)
            if (element == null) {
                throw "Unable to find element.";
            }
        }
        if (!element.getAttribute("src")) {
            throw "Image src not provided.";
        }
        // Define internal props
        this._initialized = false;
        this._restore = {
            parent: element.parentNode,
            element: element
        };
        // Wait until image is loaded before proceeding
        if (!deferred) {
            if (element.width === 0 || element.height === 0) {
                element.onload = function () {
                    _this.initialize(element);
                };
            }
            else {
                this.initialize(element);
            }
        }
    }
    /**
     * Initialize the Croppr instance
     */
    CropprCore.prototype.initialize = function (element) {
        // Create DOM elements
        this.createDOM(element);
        // Process option values
        this.options.convertToPixels(this.cropperEl);
        // Listen for events from children
        this.attachHandlerEvents();
        this.attachRegionEvents();
        this.attachOverlayEvents();
        // Bootstrap this cropper instance
        this.box = this.initializeBox(this.options);
        this.redraw();
        // Set the initalized flag to true and call the callback
        this._initialized = true;
        if (this.options.onInitialize !== null) {
            this.options.onInitialize(this);
        }
    };
    /**
     * Create Croppr's DOM elements
     */
    CropprCore.prototype.createDOM = function (targetEl) {
        // Create main container and use it as the main event listeners
        this.containerEl = document.createElement("div");
        this.containerEl.className = "croppr-container";
        this.eventBus = this.containerEl;
        enableTouch(this.containerEl);
        // Create cropper element
        this.cropperEl = document.createElement("div");
        this.cropperEl.className = "croppr";
        // Create image element
        this.imageEl = document.createElement("img");
        this.imageEl.setAttribute("src", targetEl.getAttribute("src"));
        this.imageEl.setAttribute("alt", targetEl.getAttribute("alt"));
        this.imageEl.className = "croppr-image";
        // Create clipped image element
        this.imageClippedEl = this.imageEl.cloneNode();
        this.imageClippedEl.className = "croppr-imageClipped";
        // Create region box element
        this.regionEl = document.createElement("div");
        this.regionEl.innerHTML = new Array(9)
            .fill(1)
            .map(function () { return "<div style=\"border: 1px dashed #fafafa\"></div>"; })
            .join("");
        this.regionEl.className = "croppr-region";
        // Create overlay element
        this.overlayEl = document.createElement("div");
        this.overlayEl.className = "croppr-overlay";
        // Create handles element
        var handleContainerEl = document.createElement("div");
        handleContainerEl.className = "croppr-handleContainer";
        this.handles = [];
        for (var i = 0; i < HANDLES.length; i++) {
            var handle = new Handle(HANDLES[i].position, HANDLES[i].constraints, HANDLES[i].cursor, this.eventBus);
            this.handles.push(handle);
            handleContainerEl.appendChild(handle.el);
        }
        // And then we piece it all together!
        this.cropperEl.appendChild(this.imageEl);
        this.cropperEl.appendChild(this.imageClippedEl);
        this.cropperEl.appendChild(this.regionEl);
        this.cropperEl.appendChild(this.overlayEl);
        this.cropperEl.appendChild(handleContainerEl);
        this.containerEl.appendChild(this.cropperEl);
        // And then finally insert it into the document
        targetEl.parentElement.replaceChild(this.containerEl, targetEl);
    };
    /**
     * Changes the image src.
     * @param {String} src
     */
    CropprCore.prototype.setImage = function (src) {
        var _this = this;
        // Add onload listener to reinitialize box
        this.imageEl.onload = function () {
            _this.box = _this.initializeBox(_this.options);
            _this.redraw();
        };
        // Change image source
        this.imageEl.src = src;
        this.imageClippedEl.src = src;
        return this;
    };
    /**
     * Destroy the Croppr instance and replace with the original element.
     */
    CropprCore.prototype.destroy = function () {
        this._restore.parent.replaceChild(this._restore.element, this.containerEl);
    };
    /**
     * Create a new box region with a set of options.
     * @param {Object} opts The options.
     * @returns {Box}
     */
    CropprCore.prototype.initializeBox = function (opts) {
        // Create initial box
        var width = opts.startSize.width;
        var height = opts.startSize.height;
        var box = new Box(0, 0, width, height);
        // console.log("ðŸš€ ~ file: core.ts ~ line 202 ~ CropprCore ~ initializeBox ~ box", box)
        // Maintain ratio
        box.constrainToRatio(opts.aspectRatio, [0.5, 0.5]);
        // Maintain minimum/maximum size
        var min = opts.minSize;
        var max = opts.maxSize;
        box.constrainToSize(max.width, max.height, min.width, min.height, [0.5, 0.5], opts.aspectRatio);
        // Constrain to boundary
        var parentWidth = this.cropperEl.offsetWidth;
        var parentHeight = this.cropperEl.offsetHeight;
        box.constrainToBoundary(parentWidth, parentHeight, [0.5, 0.5]);
        // // Move to center
        var x = this.cropperEl.offsetWidth / 2 - box.width() / 2;
        var y = this.cropperEl.offsetHeight / 2 - box.height() / 2;
        // console.log("ðŸš€ ~ file: core.ts ~ line 219 ~ CropprCore ~ initializeBox ~ this.cropperEl", this.cropperEl.offsetWidth)
        // console.log("ðŸš€ ~ file: core.ts ~ line 223 ~ CropprCore ~ initializeBox ~ x, y", x, y)
        box.move(x, y);
        return box;
    };
    /**
     * Draw visuals (border, handles, etc) for the current box.
     */
    CropprCore.prototype.redraw = function () {
        var _this = this;
        // Round positional values to prevent subpixel coordinates, which can
        // result in element that is rendered blurly
        var width = Math.round(this.box.width()), height = Math.round(this.box.height()), x1 = Math.round(this.box.x1), y1 = Math.round(this.box.y1), x2 = Math.round(this.box.x2), y2 = Math.round(this.box.y2);
        window.requestAnimationFrame(function () {
            // Update region element
            _this.regionEl.style.transform = "translate(".concat(x1, "px, ").concat(y1, "px)");
            _this.regionEl.style.width = width + "px";
            _this.regionEl.style.height = height + "px";
            // Update clipped image element
            _this.imageClippedEl.style.clip = "rect(".concat(y1, "px, ").concat(x2, "px, ").concat(y2, "px, ").concat(x1, "px)");
            // Determine which handle to bring forward. The following code
            // calculates the quadrant the box is in using bitwise operators.
            // Reference: https://stackoverflow.com/questions/9718059
            var center = _this.box.getAbsolutePoint([0.5, 0.5]);
            var xSign = (center[0] - _this.cropperEl.offsetWidth / 2) >> 31;
            var ySign = (center[1] - _this.cropperEl.offsetHeight / 2) >> 31;
            var quadrant = (xSign ^ ySign) + ySign + ySign + 4;
            // The following equation calculates which handle index to bring
            // forward. The equation is derived using algebra (if youre curious)
            var foregroundHandleIndex = -2 * quadrant + 8;
            // Update handle positions
            for (var i = 0; i < _this.handles.length; i++) {
                var handle = _this.handles[i];
                // Calculate handle position
                var handleWidth = handle.el.offsetWidth;
                var handleHeight = handle.el.offsetHeight;
                var left = x1 + width * handle.position[0] - handleWidth / 2;
                var top_1 = y1 + height * handle.position[1] - handleHeight / 2;
                // Apply new position. The positional values are rounded to
                // prevent subpixel positions which can result in a blurry element
                handle.el.style.transform = "translate(".concat(Math.round(left), "px, ").concat(Math.round(top_1), "px)");
                handle.el.style.zIndex = foregroundHandleIndex == i ? 5 : 4;
            }
        });
    };
    /**
     * Attach listeners for events emitted by the handles.
     * Enables resizing of the region element.
     */
    CropprCore.prototype.attachHandlerEvents = function () {
        var eventBus = this.eventBus;
        eventBus.addEventListener("handlestart", this.onHandleMoveStart.bind(this));
        eventBus.addEventListener("handlemove", this.onHandleMoveMoving.bind(this));
        eventBus.addEventListener("handleend", this.onHandleMoveEnd.bind(this));
    };
    /**
     * Attach event listeners for the crop region element.
     * Enables dragging/moving of the region element.
     */
    CropprCore.prototype.attachRegionEvents = function () {
        var eventBus = this.eventBus;
        this.regionEl.addEventListener("mousedown", onMouseDown);
        eventBus.addEventListener("regionstart", this.onRegionMoveStart.bind(this));
        eventBus.addEventListener("regionmove", this.onRegionMoveMoving.bind(this));
        eventBus.addEventListener("regionend", this.onRegionMoveEnd.bind(this));
        function onMouseDown(e) {
            e.stopPropagation();
            document.addEventListener("mouseup", onMouseUp);
            document.addEventListener("mousemove", onMouseMove);
            // Notify parent
            eventBus.dispatchEvent(new CustomEvent("regionstart", {
                detail: { mouseX: e.clientX, mouseY: e.clientY }
            }));
        }
        function onMouseMove(e) {
            e.stopPropagation();
            // Notify parent
            eventBus.dispatchEvent(new CustomEvent("regionmove", {
                detail: { mouseX: e.clientX, mouseY: e.clientY }
            }));
        }
        function onMouseUp(e) {
            e.stopPropagation();
            document.removeEventListener("mouseup", onMouseUp);
            document.removeEventListener("mousemove", onMouseMove);
            // Notify parent
            eventBus.dispatchEvent(new CustomEvent("regionend", {
                detail: { mouseX: e.clientX, mouseY: e.clientY }
            }));
        }
    };
    /**
     * Attach event listeners for the overlay element.
     * Enables the creation of a new selection by dragging an empty area.
     */
    CropprCore.prototype.attachOverlayEvents = function () {
        var SOUTHEAST_HANDLE_IDX = 4;
        var self = this;
        var tmpBox = null;
        this.overlayEl.addEventListener("mousedown", onMouseDown);
        function onMouseDown(e) {
            e.stopPropagation();
            document.addEventListener("mouseup", onMouseUp);
            document.addEventListener("mousemove", onMouseMove);
            // Calculate mouse's position in relative to the container
            var container = self.cropperEl.getBoundingClientRect();
            var mouseX = e.clientX - container.left;
            var mouseY = e.clientY - container.top;
            // Create new box at mouse position
            tmpBox = self.box;
            self.box = new Box(mouseX, mouseY, mouseX + 1, mouseY + 1);
            // Activate the bottom right handle
            self.eventBus.dispatchEvent(new CustomEvent("handlestart", {
                detail: { handle: self.handles[SOUTHEAST_HANDLE_IDX] }
            }));
        }
        function onMouseMove(e) {
            e.stopPropagation();
            self.eventBus.dispatchEvent(new CustomEvent("handlemove", {
                detail: { mouseX: e.clientX, mouseY: e.clientY }
            }));
        }
        function onMouseUp(e) {
            e.stopPropagation();
            document.removeEventListener("mouseup", onMouseUp);
            document.removeEventListener("mousemove", onMouseMove);
            // If the new box has no width and height, it suggests that
            // the user had just clicked on an empty area and did not drag
            // a new box (ie. an accidental click). In this scenario, we
            // simply replace it with the previous box.
            if (self.box.width() === 1 && self.box.height() === 1) {
                self.box = tmpBox;
                return;
            }
            self.eventBus.dispatchEvent(new CustomEvent("handleend", {
                detail: { mouseX: e.clientX, mouseY: e.clientY }
            }));
        }
    };
    /**
     * EVENT HANDLER
     * Executes when user begins dragging a handle.
     */
    CropprCore.prototype.onHandleMoveStart = function (e) {
        var handle = e.detail.handle;
        // The origin point is the point where the box is scaled from.
        // This is usually the opposite side/corner of the active handle.
        var originPoint = [1 - handle.position[0], 1 - handle.position[1]];
        var _a = this.box.getAbsolutePoint(originPoint), originX = _a[0], originY = _a[1];
        this.activeHandle = { handle: handle, originPoint: originPoint, originX: originX, originY: originY };
        // Trigger callback
        if (this.options.onCropStart !== null) {
            this.options.onCropStart(this.getValue());
        }
    };
    /**
     * EVENT HANDLER
     * Executes on handle move. Main logic to manage the movement of handles.
     */
    CropprCore.prototype.onHandleMoveMoving = function (e) {
        var _a = e.detail, mouseX = _a.mouseX, mouseY = _a.mouseY;
        // Calculate mouse's position in relative to the container
        var container = this.cropperEl.getBoundingClientRect();
        mouseX = mouseX - container.left;
        mouseY = mouseY - container.top;
        // Ensure mouse is within the boundaries
        if (mouseX < 0) {
            mouseX = 0;
        }
        else if (mouseX > container.width) {
            mouseX = container.width;
        }
        if (mouseY < 0) {
            mouseY = 0;
        }
        else if (mouseY > container.height) {
            mouseY = container.height;
        }
        // Bootstrap helper variables
        var origin = this.activeHandle.originPoint.slice();
        var originX = this.activeHandle.originX;
        var originY = this.activeHandle.originY;
        var handle = this.activeHandle.handle;
        var TOP_MOVABLE = handle.constraints[0] === 1;
        var RIGHT_MOVABLE = handle.constraints[1] === 1;
        var BOTTOM_MOVABLE = handle.constraints[2] === 1;
        var LEFT_MOVABLE = handle.constraints[3] === 1;
        var MULTI_AXIS = (LEFT_MOVABLE || RIGHT_MOVABLE) && (TOP_MOVABLE || BOTTOM_MOVABLE);
        // Apply movement to respective sides according to the handle's
        // constraint values.
        var x1 = LEFT_MOVABLE || RIGHT_MOVABLE ? originX : this.box.x1;
        var x2 = LEFT_MOVABLE || RIGHT_MOVABLE ? originX : this.box.x2;
        var y1 = TOP_MOVABLE || BOTTOM_MOVABLE ? originY : this.box.y1;
        var y2 = TOP_MOVABLE || BOTTOM_MOVABLE ? originY : this.box.y2;
        x1 = LEFT_MOVABLE ? mouseX : x1;
        x2 = RIGHT_MOVABLE ? mouseX : x2;
        y1 = TOP_MOVABLE ? mouseY : y1;
        y2 = BOTTOM_MOVABLE ? mouseY : y2;
        // Check if the user dragged past the origin point. If it did,
        // we set the flipped flag to true.
        var _b = [false, false], isFlippedX = _b[0], isFlippedY = _b[1];
        if (LEFT_MOVABLE || RIGHT_MOVABLE) {
            isFlippedX = LEFT_MOVABLE ? mouseX > originX : mouseX < originX;
        }
        if (TOP_MOVABLE || BOTTOM_MOVABLE) {
            isFlippedY = TOP_MOVABLE ? mouseY > originY : mouseY < originY;
        }
        // If it is flipped, we swap the coordinates and flip the origin point.
        if (isFlippedX) {
            var tmp = x1;
            x1 = x2;
            x2 = tmp; // Swap x1 and x2
            origin[0] = 1 - origin[0]; // Flip origin x point
        }
        if (isFlippedY) {
            var tmp = y1;
            y1 = y2;
            y2 = tmp; // Swap y1 and y2
            origin[1] = 1 - origin[1]; // Flip origin y point
        }
        // Create new box object
        var box = new Box(x1, y1, x2, y2);
        // Maintain aspect ratio
        if (this.options.aspectRatio) {
            var ratio = this.options.aspectRatio;
            var isVerticalMovement = false;
            if (MULTI_AXIS) {
                isVerticalMovement =
                    mouseY > box.y1 + ratio * box.width() ||
                        mouseY < box.y2 - ratio * box.width();
            }
            else if (TOP_MOVABLE || BOTTOM_MOVABLE) {
                isVerticalMovement = true;
            }
            var ratioMode = isVerticalMovement ? "width" : "height";
            box.constrainToRatio(ratio, origin, ratioMode);
        }
        // Maintain minimum/maximum size
        var min = this.options.minSize;
        var max = this.options.maxSize;
        box.constrainToSize(max.width, max.height, min.width, min.height, origin, this.options.aspectRatio);
        // Constrain to boundary
        var parentWidth = this.cropperEl.offsetWidth;
        var parentHeight = this.cropperEl.offsetHeight;
        box.constrainToBoundary(parentWidth, parentHeight, origin);
        // Finally, update the visuals (border, handles, clipped image, etc)
        this.box = box;
        this.redraw();
        // Trigger callback
        if (this.options.onCropMove !== null) {
            this.options.onCropMove(this.getValue());
        }
    };
    /**
     * EVENT HANDLER
     * Executes on handle move end.
     */
    CropprCore.prototype.onHandleMoveEnd = function (e) {
        // Trigger callback
        if (this.options.onCropEnd !== null) {
            this.options.onCropEnd(this.getValue());
        }
    };
    /**
     * EVENT HANDLER
     * Executes when user starts moving the crop region.
     */
    CropprCore.prototype.onRegionMoveStart = function (e) {
        var _a = e.detail, mouseX = _a.mouseX, mouseY = _a.mouseY;
        // Calculate mouse's position in relative to the container
        var container = this.cropperEl.getBoundingClientRect();
        mouseX = mouseX - container.left;
        mouseY = mouseY - container.top;
        this.currentMove = {
            offsetX: mouseX - this.box.x1,
            offsetY: mouseY - this.box.y1
        };
        // Trigger callback
        if (this.options.onCropStart !== null) {
            this.options.onCropStart(this.getValue());
        }
    };
    /**
     * EVENT HANDLER
     * Executes when user moves the crop region.
     */
    CropprCore.prototype.onRegionMoveMoving = function (e) {
        var _a = e.detail, mouseX = _a.mouseX, mouseY = _a.mouseY;
        var _b = this.currentMove, offsetX = _b.offsetX, offsetY = _b.offsetY;
        // Calculate mouse's position in relative to the container
        var container = this.cropperEl.getBoundingClientRect();
        mouseX = mouseX - container.left;
        mouseY = mouseY - container.top;
        this.box.move(mouseX - offsetX, mouseY - offsetY);
        // Ensure box is within the boundaries
        if (this.box.x1 < 0) {
            this.box.move(0, null);
        }
        if (this.box.x2 > container.width) {
            this.box.move(container.width - this.box.width(), null);
        }
        if (this.box.y1 < 0) {
            this.box.move(null, 0);
        }
        if (this.box.y2 > container.height) {
            this.box.move(null, container.height - this.box.height());
        }
        // Update visuals
        this.redraw();
        // Trigger callback
        if (this.options.onCropMove !== null) {
            this.options.onCropMove(this.getValue());
        }
    };
    /**
     * EVENT HANDLER
     * Executes when user stops moving the crop region (mouse up).
     */
    CropprCore.prototype.onRegionMoveEnd = function (e) {
        // Trigger callback
        if (this.options.onCropEnd !== null) {
            this.options.onCropEnd(this.getValue());
        }
    };
    /**
     * Calculate the value of the crop region.
     */
    CropprCore.prototype.getValue = function (mode) {
        if (mode === void 0) { mode = null; }
        if (mode === null) {
            mode = this.options.returnMode;
        }
        if (mode == "real") {
            var actualWidth = this.imageEl.naturalWidth;
            var actualHeight = this.imageEl.naturalHeight;
            var _a = this.imageEl.getBoundingClientRect(), elementWidth = _a.width, elementHeight = _a.height;
            var factorX = actualWidth / elementWidth;
            var factorY = actualHeight / elementHeight;
            return {
                x: Math.round(this.box.x1 * factorX),
                y: Math.round(this.box.y1 * factorY),
                width: Math.round(this.box.width() * factorX),
                height: Math.round(this.box.height() * factorY)
            };
        }
        else if (mode == "ratio") {
            var _b = this.imageEl.getBoundingClientRect(), elementWidth = _b.width, elementHeight = _b.height;
            return {
                x: round(this.box.x1 / elementWidth, 3),
                y: round(this.box.y1 / elementHeight, 3),
                width: round(this.box.width() / elementWidth, 3),
                height: round(this.box.height() / elementHeight, 3)
            };
        }
        else if (mode == "raw") {
            return {
                x: Math.round(this.box.x1),
                y: Math.round(this.box.y1),
                width: Math.round(this.box.width()),
                height: Math.round(this.box.height())
            };
        }
    };
    /**
     * Parse user options and set default values.
     */
    CropprCore.parseOptions = function (opts) {
        var defaults = {
            aspectRatio: null,
            maxSize: { width: null, height: null },
            minSize: { width: null, height: null },
            startSize: { width: 100, height: 100, unit: "%" },
            returnMode: "real",
            onInitialize: null,
            onCropStart: null,
            onCropMove: null,
            onCropEnd: null
        };
        // Parse aspect ratio
        var aspectRatio = null;
        if (opts.aspectRatio !== undefined) {
            if (typeof opts.aspectRatio === "number") {
                aspectRatio = opts.aspectRatio;
            }
            else if (opts.aspectRatio instanceof Array) {
                aspectRatio = opts.aspectRatio[1] / opts.aspectRatio[0];
            }
        }
        // Parse max width/height
        var maxSize = null;
        if (opts.maxSize !== undefined && opts.maxSize !== null) {
            maxSize = {
                width: opts.maxSize[0] || null,
                height: opts.maxSize[1] || null,
                unit: opts.maxSize[2] || "px"
            };
        }
        // Parse min width/height
        var minSize = null;
        if (opts.minSize !== undefined && opts.minSize !== null) {
            minSize = {
                width: opts.minSize[0] || null,
                height: opts.minSize[1] || null,
                unit: opts.minSize[2] || "px"
            };
        }
        // Parse start size
        var startSize = null;
        if (opts.startSize !== undefined && opts.startSize !== null) {
            startSize = {
                width: opts.startSize[0] || null,
                height: opts.startSize[1] || null,
                unit: opts.startSize[2] || "%"
            };
        }
        // Parse callbacks
        var onInitialize = null;
        if (typeof opts.onInitialize === "function") {
            onInitialize = opts.onInitialize;
        }
        var onCropStart = null;
        if (typeof opts.onCropStart === "function") {
            onCropStart = opts.onCropStart;
        }
        var onCropEnd = null;
        if (typeof opts.onCropEnd === "function") {
            onCropEnd = opts.onCropEnd;
        }
        var onCropMove = null;
        if (typeof opts.onUpdate === "function") {
            // DEPRECATED: onUpdate is deprecated to create a more uniform
            // callback API, such as: onCropStart, onCropMove, onCropEnd
            console.warn("Croppr.js: `onUpdate` is deprecated and will be removed in the next major release. Please use `onCropMove` or `onCropEnd` instead.");
            onCropMove = opts.onUpdate;
        }
        if (typeof opts.onCropMove === "function") {
            onCropMove = opts.onCropMove;
        }
        // Parse returnMode value
        var returnMode = null;
        if (opts.returnMode !== undefined) {
            var s = opts.returnMode.toLowerCase();
            if (["real", "ratio", "raw"].indexOf(s) === -1) {
                throw "Invalid return mode.";
            }
            returnMode = s;
        }
        // Create function to convert % values to pixels
        var convertToPixels = function (container) {
            var width = container.offsetWidth;
            var height = container.offsetHeight;
            // Convert sizes
            var sizeKeys = ["maxSize", "minSize", "startSize"];
            for (var i = 0; i < sizeKeys.length; i++) {
                var key = sizeKeys[i];
                if (this[key] !== null) {
                    if (this[key].unit == "%") {
                        if (this[key].width !== null) {
                            this[key].width = (this[key].width / 100) * width;
                        }
                        if (this[key].height !== null) {
                            this[key].height = (this[key].height / 100) * height;
                        }
                    }
                    delete this[key].unit;
                }
            }
        };
        var defaultValue = function (v, d) { return (v !== null ? v : d); };
        return {
            aspectRatio: defaultValue(aspectRatio, defaults.aspectRatio),
            maxSize: defaultValue(maxSize, defaults.maxSize),
            minSize: defaultValue(minSize, defaults.minSize),
            startSize: defaultValue(startSize, defaults.startSize),
            returnMode: defaultValue(returnMode, defaults.returnMode),
            onInitialize: defaultValue(onInitialize, defaults.onInitialize),
            onCropStart: defaultValue(onCropStart, defaults.onCropStart),
            onCropMove: defaultValue(onCropMove, defaults.onCropMove),
            onCropEnd: defaultValue(onCropEnd, defaults.onCropEnd),
            convertToPixels: convertToPixels
        };
    };
    return CropprCore;
}());
/**
 * HELPER FUNCTIONS
 */
function round(value, decimals) {
    return Number(Math.round((value + "e" + decimals)) + "e-" + decimals);
}

/**
 * Croppr.js
 * https://github.com/jamesssooi/Croppr.js
 *
 * A JavaScript image cropper that's lightweight, awesome, and has
 * zero dependencies.
 *
 * (C) 2017 James Ooi. Released under the MIT License.
 */
/**
 * This class is a wrapper for CropprCore that merely implements the main
 * interfaces for the Croppr instance. Look into CropprCore for all the
 * main logic.
 */
var Croppr = /** @class */ (function (_super) {
    __extends(Croppr, _super);
    /**
     * @constructor
     * Calls the CropprCore's constructor.
     */
    function Croppr(element, options, _deferred) {
        if (_deferred === void 0) { _deferred = false; }
        return _super.call(this, element, options, _deferred) || this;
    }
    /**
     * Gets the value of the crop region.
     * @param {String} [mode] Which mode of calculation to use: 'real', 'ratio' or
     *      'raw'.
     */
    Croppr.prototype.getValue = function (mode) {
        return _super.prototype.getValue.call(this, mode);
    };
    /**
     * Changes the image src.
     * @param {String} src
     */
    Croppr.prototype.setImage = function (src) {
        return _super.prototype.setImage.call(this, src);
    };
    /**
     * Destroys the Croppr instance
     */
    Croppr.prototype.destroy = function () {
        return _super.prototype.destroy.call(this);
    };
    /**
     * Moves the crop region to a specified coordinate.
     * @param {Number} x
     * @param {Number} y
     */
    Croppr.prototype.moveTo = function (x, y) {
        this.box.move(x, y);
        this.redraw();
        // Call the callback
        if (this.options.onCropEnd !== null) {
            this.options.onCropEnd(this.getValue());
        }
        return this;
    };
    /**
     * Resizes the crop region to a specified width and height.
     * @param {Number} width
     * @param {Number} height
     * @param {Array} origin The origin point to resize from.
     *      Defaults to [0.5, 0.5] (center).
     */
    Croppr.prototype.resizeTo = function (width, height, origin) {
        if (origin === void 0) { origin = [0.5, 0.5]; }
        this.box.resize(width, height, origin);
        //////////////////////////////////////////////////////////////////
        var parentWidth = this.cropperEl.offsetWidth;
        var parentHeight = this.cropperEl.offsetHeight;
        this.box.constrainToBoundary(parentWidth, parentHeight, [0.5, 0.5]);
        ///////////////////////////////////////////////////////////////////
        this.redraw();
        // Call the callback
        if (this.options.onCropEnd !== null) {
            this.options.onCropEnd(this.getValue());
        }
        return this;
    };
    /**
     * Scale the crop region by a factor.
     * @param {Number} factor
     * @param {Array} origin The origin point to resize from.
     *      Defaults to [0.5, 0.5] (center).
     */
    Croppr.prototype.scaleBy = function (factor, origin) {
        if (origin === void 0) { origin = [0.5, 0.5]; }
        this.box.scale(factor, origin);
        this.redraw();
        // Call the callback
        if (this.options.onCropEnd !== null) {
            this.options.onCropEnd(this.getValue());
        }
        return this;
    };
    /**
     * Resets the crop region to the initial settings.
     */
    Croppr.prototype.reset = function (newOptions) {
        if (newOptions) {
            this.options = __assign(__assign({}, this.options), { newOptions: newOptions });
        }
        this.box = this.initializeBox(this.options);
        // console.log('ðŸš€ ~ file: croppr.ts ~ line 110 ~ Croppr ~ reset ~ this.box', this.box);
        this.redraw();
        // Call the callback
        if (this.options.onCropEnd !== null) {
            this.options.onCropEnd(this.getValue());
        }
        return this;
    };
    Croppr.prototype.enableVisibility = function (state) {
        var croppContainer = document.querySelector(".croppr-container");
        if (!croppContainer)
            throw new Error("THere is not any croppr");
        if (state) {
            croppContainer.style.display = "block";
        }
        else {
            croppContainer.style.display = "none";
        }
    };
    return Croppr;
}(CropprCore));

var CropprWrapper = memo(function (_a) {
    var src = _a.src, size = _a.size, croppUpdate = _a.croppUpdate;
    var _b = useState(), imageSrc = _b[0], setImageSrc = _b[1];
    var _c = useState({ width: 150, height: 150 }), croppSize = _c[0], setCroppSize = _c[1];
    var croppr = useRef(null);
    var mount = useRef();
    useEffect(function () {
        if (size) {
            setCroppSize(__assign({}, size));
            if (croppr.current)
                croppr.current.resizeTo(size.width, size.height);
        }
    }, [size]);
    useEffect(function () {
        if (src) {
            setImageSrc(src);
        }
    }, [src]);
    useEffect(function () {
        if (mount.current && imageSrc) {
            croppr.current = new Croppr('#croppr', {
                minSize: [32, 32, 'px'],
                startSize: [croppSize.width, croppSize.height, 'px'],
                onInitialize: function (data) {
                    croppUpdate(data === null || data === void 0 ? void 0 : data.getValue());
                },
                onCropEnd: function (data) {
                    croppUpdate(data);
                }
            });
        }
        return function () { var _a; return ((_a = croppr === null || croppr === void 0 ? void 0 : croppr.current) === null || _a === void 0 ? void 0 : _a.destroy()); };
    }, [mount.current, imageSrc]);
    return React.createElement("div", { className: 'CropprWrapper' },
        React.createElement("img", { ref: mount, src: imageSrc, id: "croppr" }));
});

var _initialState = {
    quality: 92,
    maxHeight: 1000,
    maxWidth: 1000,
    cropHeight: 150,
    cropWidth: 150,
    maintainAspectRatio: true,
    format: 'jpeg',
    arrayCopiedImages: [],
    originImageSrc: ''
};
var EditImage = memo(function (_a) {
    var _b;
    var _c = _a.labels, labels = _c === void 0 ? {} : _c, _d = _a.image, image = _d === void 0 ? '' : _d, _e = _a.color, color = _e === void 0 ? '#1e88e5' : _e, _f = _a.initialState, initialState = _f === void 0 ? _initialState : _f, rtl = _a.rtl, dark = _a.dark, _g = _a.saveUpdates, saveUpdates = _g === void 0 ? function () { } : _g;
    var _h = useState(initialState), state = _h[0], setState = _h[1];
    var _j = useState(''), imageSrc = _j[0], setImageSrc = _j[1];
    var _k = useState(false), showCrop = _k[0], setShowCrop = _k[1];
    var _l = useState({
        width: 150,
        height: 150
    }), croppSize = _l[0], setCroppSize = _l[1];
    var _m = useState(), croppState = _m[0], setCroppState = _m[1];
    var isMobile = useRef(false);
    var allFormats = ['webp', 'jpeg', 'png'];
    useEffect(function () {
        isMobile.current = window.innerWidth < 800;
        setState(JSON.parse(JSON.stringify(__assign(__assign({}, state), initialState))));
    }, [initialState]);
    useEffect(function () {
        setImageSrc(image);
    }, [image]);
    useEffect(function () {
        if (!showCrop) {
            setCroppSize({ width: 150, height: 150 });
        }
    }, [showCrop]);
    function applyChanges(stateIntance, changeHeight) {
        if (changeHeight === void 0) { changeHeight = false; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, newState, imageUri, error_1;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _b.trys.push([0, 2, , 3]);
                        return [4 /*yield*/, convertImageUsingCanvas(state.originImageSrc, changeHeight, stateIntance)];
                    case 1:
                        _a = _b.sent(), newState = _a.state, imageUri = _a.imageUri;
                        setImageSrc(imageUri);
                        setState(newState);
                        return [3 /*break*/, 3];
                    case 2:
                        error_1 = _b.sent();
                        console.log('ðŸš€ ~ file: EditImage.tsx ~ line 73 ~ applyChanges ~ error', error_1);
                        return [3 /*break*/, 3];
                    case 3: return [2 /*return*/];
                }
            });
        });
    }
    function onUpdateQuality(quality) {
        return __awaiter(this, void 0, void 0, function () {
            var newState, error_2;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        quality = Math.max(Math.min(quality, 100), 1);
                        newState = __assign(__assign({}, state), { quality: quality });
                        setState(newState);
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, applyChanges(newState, false)];
                    case 2:
                        _a.sent();
                        return [3 /*break*/, 4];
                    case 3:
                        error_2 = _a.sent();
                        console.log('onUpdateQuality ~ error', error_2);
                        return [3 /*break*/, 4];
                    case 4: return [2 /*return*/];
                }
            });
        });
    }
    function onChangeSize(value, changeHeight) {
        if (changeHeight === void 0) { changeHeight = false; }
        return __awaiter(this, void 0, void 0, function () {
            var m, newState, error_3;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        m = Math.max(Math.min(value, 4000), 32);
                        newState = __assign({}, state);
                        if (changeHeight) {
                            if (newState.maxHeight === m)
                                return [2 /*return*/];
                            newState.maxHeight = m;
                        }
                        else {
                            if (newState.maxWidth === m)
                                return [2 /*return*/];
                            newState.maxWidth = m;
                        }
                        setState(newState);
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, applyChanges(newState, changeHeight)];
                    case 2:
                        _a.sent();
                        return [3 /*break*/, 4];
                    case 3:
                        error_3 = _a.sent();
                        console.log('onChangeSize ~ error', error_3);
                        return [3 /*break*/, 4];
                    case 4: return [2 /*return*/];
                }
            });
        });
    }
    function onChangeFormat(e) {
        return __awaiter(this, void 0, void 0, function () {
            var newState, error_4;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        newState = __assign(__assign({}, state), { format: e.target.value });
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        setState(newState);
                        return [4 /*yield*/, applyChanges(newState, false)];
                    case 2:
                        _a.sent();
                        return [3 /*break*/, 4];
                    case 3:
                        error_4 = _a.sent();
                        console.log('onChangeFormat ~ error', error_4);
                        return [3 /*break*/, 4];
                    case 4: return [2 /*return*/];
                }
            });
        });
    }
    function onChangeCrop(width, height) {
        if (width) {
            setState(__assign(__assign({}, state), { cropWidth: width }));
            setCroppSize(__assign(__assign({}, croppSize), { width: width }));
        }
        if (height) {
            setState(__assign(__assign({}, state), { cropHeight: height }));
            setCroppSize(__assign(__assign({}, croppSize), { height: height }));
        }
    }
    function onCrop() {
        var newState = _cloneObject(state);
        var canvas = document.createElement('canvas');
        return new Promise(function (resolve, reject) {
            var ctx = canvas.getContext('2d');
            var image = new Image();
            image.src = imageSrc;
            image.onload = function () {
                var newWidth = croppState === null || croppState === void 0 ? void 0 : croppState.width;
                var newHeight = croppState === null || croppState === void 0 ? void 0 : croppState.height;
                canvas.height = newHeight;
                canvas.width = newWidth;
                ctx.drawImage(image, Math.abs(croppState === null || croppState === void 0 ? void 0 : croppState.x), Math.abs(croppState === null || croppState === void 0 ? void 0 : croppState.y), croppState === null || croppState === void 0 ? void 0 : croppState.width, croppState === null || croppState === void 0 ? void 0 : croppState.height, 0, 0, croppState === null || croppState === void 0 ? void 0 : croppState.width, croppState === null || croppState === void 0 ? void 0 : croppState.height);
                return resolve(canvas.toDataURL("image/".concat(newState.format), newState.quality));
            };
            image.onerror = function (e) {
                reject(e);
            };
        })
            .then(function (dataUri) {
            newState.maxWidth = canvas.width;
            newState.maxHeight = canvas.height;
            newState.originImageSrc = dataUri;
            newState = saveState(newState, dataUri);
            setState(newState);
            setImageSrc(dataUri);
            setShowCrop(false);
        })["catch"](function (e) {
            console.log(e);
        });
    }
    function onCroppUpdate(data) {
        setCroppState(data);
        setState(__assign(__assign({}, state), { cropHeight: data.height, cropWidth: data.width }));
    }
    function onCloseEditPanel(saveChanges) {
        if (saveChanges === void 0) { saveChanges = false; }
        setShowCrop(false);
        if (saveChanges)
            saveUpdates({ state: state, imageSrc: imageSrc });
        else
            saveUpdates(null);
    }
    function onRestore() {
        return __awaiter(this, void 0, void 0, function () {
            var newState, newValue;
            return __generator(this, function (_a) {
                try {
                    newState = _cloneObject(state);
                    if (newState.arrayCopiedImages.length > 1) {
                        newState.arrayCopiedImages.pop();
                        newValue = newState.arrayCopiedImages[newState.arrayCopiedImages.length - 1];
                        newState = __assign(__assign({}, state), { arrayCopiedImages: newState.arrayCopiedImages, maxHeight: newValue.height, maxWidth: newValue.width, quality: newValue.quality, format: newValue.format, originImageSrc: newValue.originImageSrc, basicFilters: newValue.basicFilters });
                        setState(newState);
                        setImageSrc(newValue.lastImage);
                    }
                }
                catch (e) {
                    console.log('ðŸš€ ~ file: edit-image.component.ts ~ line 126 ~ EditImageComponent ~ onRestore ~ e', e);
                }
                return [2 /*return*/];
            });
        });
    }
    function onChangeFilters(data) {
        return __awaiter(this, void 0, void 0, function () {
            var newState, e_1;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _a.trys.push([0, 2, , 3]);
                        newState = _cloneObject(state);
                        if (!newState.basicFilters) {
                            newState.basicFilters = data;
                        }
                        else {
                            newState.basicFilters = __assign(__assign({}, newState.basicFilters), data);
                        }
                        return [4 /*yield*/, applyChanges(newState, false)];
                    case 1:
                        _a.sent();
                        return [3 /*break*/, 3];
                    case 2:
                        e_1 = _a.sent();
                        console.log('ðŸš€ ~ file: EditImage.tsx ~ line 259 ~ onChangeFilters ~ e', e_1);
                        return [3 /*break*/, 3];
                    case 3: return [2 /*return*/];
                }
            });
        });
    }
    var sizeImage = useMemo(function () {
        if (imageSrc && imageSrc.length) {
            return Math.ceil(((3 / 4) * imageSrc.length) / 1024);
        }
        else {
            return '';
        }
    }, [imageSrc]);
    function _cloneObject(obj) {
        return JSON.parse(JSON.stringify(obj));
    }
    return (React.createElement("div", { className: "EditImage ".concat(dark ? "dark" : "") },
        React.createElement("div", { id: 'popup', className: 'popup' },
            React.createElement("div", { style: {
                    flexDirection: 'row',
                    boxSizing: 'border-box',
                    display: 'flex',
                    placeContent: 'center flex-end',
                    alignItems: 'center',
                    padding: '0px 16px'
                } },
                React.createElement("button", { className: 'icon-btn', onClick: function () {
                        onCloseEditPanel(false);
                    } },
                    React.createElement("span", { className: 'material-icons' }, "clear"))),
            React.createElement("div", { className: 'image-container' },
                React.createElement("div", { className: 'image-holder-full' },
                    !showCrop && React.createElement("img", { id: 'image-full', src: imageSrc }),
                    showCrop && (React.createElement(CropprWrapper, { src: imageSrc, size: croppSize, croppUpdate: onCroppUpdate }))),
                React.createElement("div", { className: 'control-panel' },
                    React.createElement(TabContainer, { lazy: true, borderLine: true },
                        React.createElement(TabItem, { name: labels['Basic'] },
                            (!isMobile.current || (isMobile.current && !showCrop)) && (React.createElement(React.Fragment, null,
                                React.createElement("div", { style: { display: 'flex', width: '100%', justifyContent: 'space-between' } },
                                    React.createElement("p", { className: 'item-panel' }, labels['Quality']),
                                    React.createElement("p", { className: 'item-panel' }, state.quality + '%')),
                                React.createElement("div", { className: 'flex-row-start' },
                                    React.createElement(Input, { readOnly: showCrop, disabled: showCrop, className: 'input-range', onChangedDelayed: onUpdateQuality, onChangedValue: function (value) {
                                            setState(__assign(__assign({}, state), { quality: value }));
                                        }, style: {
                                            maxWidth: '100%',
                                            width: '100%',
                                            color: color
                                        }, type: 'range', min: 1, max: 100, value: state.quality })),
                                React.createElement("div", { className: 'item-panel', style: { display: 'flex', width: '100%', justifyContent: 'space-between' } },
                                    labels['Max dimensions'],
                                    React.createElement("div", { style: { display: 'flex', alignItems: 'center', gap: ".5rem" } },
                                        React.createElement("input", { disabled: showCrop, readOnly: showCrop, type: 'checkbox', checked: state.maintainAspectRatio, onChange: function (e) {
                                                return setState(__assign(__assign({}, state), { maintainAspectRatio: e.target.checked }));
                                            }, style: { color: color } }),
                                        React.createElement("span", { className: 'caption' }, labels['aspect-ratio']))),
                                React.createElement("div", { className: 'flex-row-start', style: { marginTop: '10px', justifyContent: 'space-between' } },
                                    React.createElement("div", { className: 'form-field', style: { maxWidth: '48%', width: '48%' } },
                                        React.createElement("label", null, labels['max-width(px)']),
                                        React.createElement(Input, { readOnly: showCrop, disabled: showCrop, placeholder: labels['max-width(px)'], value: state.maxWidth, onChangedValue: function (value) {
                                                return setState(__assign(__assign({}, state), { maxWidth: value }));
                                            }, type: 'number', min: 0, max: 2000, onInputChangedEnd: function (value) {
                                                onChangeSize(value, false);
                                            } })),
                                    React.createElement("div", { className: 'form-field', style: { maxWidth: '48%', width: '48%' } },
                                        React.createElement("label", null, labels['max-height(px)']),
                                        React.createElement(Input, { readOnly: showCrop, disabled: showCrop, placeholder: labels['max-height(px)'], value: state.maxHeight, onChangedValue: function (value) {
                                                return setState(__assign(__assign({}, state), { maxHeight: value }));
                                            }, type: 'number', min: 0, max: 2000, onInputChangedEnd: function (value) {
                                                onChangeSize(value, true);
                                            } }))),
                                React.createElement("p", { className: 'item-panel' }, labels['Format']),
                                React.createElement("div", { className: 'flex-row-start', style: { marginTop: '10px', justifyContent: 'space-between' } },
                                    React.createElement("div", { className: 'form-field', style: { width: '100%' } },
                                        React.createElement("select", { disabled: showCrop, value: state.format, onChange: onChangeFormat }, allFormats.map(function (formatItem, index) { return (React.createElement("option", { key: index, value: formatItem }, formatItem)); })))))),
                            React.createElement("div", { className: 'flex-row-start', style: { marginTop: '5px', justifyContent: 'space-between' } },
                                React.createElement("span", { style: { display: 'flex', alignItems: 'center', gap: ".5rem" } },
                                    React.createElement("input", { type: 'checkbox', onChange: function (e) {
                                            setShowCrop(e.target.checked);
                                        }, checked: showCrop, style: { color: color, marginBottom: '3px' } }),
                                    React.createElement("span", { className: 'item-panel', style: { marginLeft: '4px' } }, labels['Crop']))),
                            showCrop && (React.createElement(React.Fragment, null,
                                React.createElement("div", { className: 'flex-row-start', style: { marginTop: '10px', justifyContent: 'space-between' } },
                                    React.createElement("div", { className: 'form-field', style: { maxWidth: '48%', width: '48%' } },
                                        React.createElement("label", null, labels['width(px)']),
                                        React.createElement(Input, { type: 'number', min: 0, value: state.cropWidth, onChangedValue: function (value) {
                                                return setState(__assign(__assign({}, state), { cropWidth: value }));
                                            }, onInputChangedEnd: function (value) {
                                                onChangeCrop(+value, null);
                                            }, placeholder: labels['width(px)'] })),
                                    React.createElement("div", { className: 'form-field', style: { maxWidth: '48%', width: '48%' } },
                                        React.createElement("label", null, labels['height(px)']),
                                        React.createElement(Input, { type: 'number', min: 0, value: state.cropHeight, onInputChangedEnd: function (value) {
                                                onChangeCrop(null, +value);
                                            }, onChangedValue: function (value) {
                                                return setState(__assign(__assign({}, state), { cropHeight: value }));
                                            }, placeholder: labels['height(px)'] }))),
                                React.createElement("p", { style: { marginBottom: '4px !important' } },
                                    React.createElement("button", { title: labels['Confirm Crop'], className: 'icon-btn', onClick: onCrop },
                                        React.createElement("span", { className: 'material-icons' }, " crop "),
                                        React.createElement("span", { style: { color: '#fff', marginLeft: 8 } }, labels['Confirm Crop'])))))),
                        React.createElement(TabItem, { disabled: showCrop, name: labels['Filters'] },
                            React.createElement(BasicFilter, { color: color, labels: labels, initialState: state.basicFilters, changeFilter: onChangeFilters }))),
                    React.createElement("button", { title: labels['Undo'], disabled: state.arrayCopiedImages.length <= 1, style: (_b = { position: 'absolute' }, _b[rtl ? 'left' : 'right'] = '10px', _b.top = '30px', _b), className: 'icon-btn', onClick: onRestore },
                        React.createElement("span", { className: 'material-icons' }, " refresh ")),
                    React.createElement("div", { className: 'flex-row-start', style: { marginTop: '10px', justifyContent: 'space-between', alignItems: 'center' } },
                        React.createElement("button", { className: 'save-btn', disabled: showCrop, onClick: function () {
                                onCloseEditPanel(true);
                            } }, labels['Save']),
                        sizeImage && (React.createElement("p", { className: 'caption image-caption', style: {
                                color: sizeImage > 120 ? '#f44336' : 'unset',
                                fontWeight: sizeImage > 120 ? '500' : 'unset'
                            } },
                            "size: ",
                            sizeImage,
                            "Kb \u00A0 ",
                            state.format))))))));
});

var initialConfig = {
    language: 'en',
    objectFit: 'cover',
    hideDeleteBtn: false,
    hideDownloadBtn: false,
    hideEditBtn: false,
    hideAddBtn: false,
    rtl: false,
    darkMode: false,
    compressInitial: null
};
var initialState = {
    maxHeight: 3000,
    maxWidth: 3000,
    cropHeight: 150,
    cropWidth: 150,
    maintainAspectRatio: true,
    format: 'jpeg',
    arrayCopiedImages: [],
    originImageSrc: '',
    basicFilters: undefined,
    quality: 100
};
var ReactImagePickerEditor = memo(function (_a) {
    var _b = _a.config, config = _b === void 0 ? {} : _b, _c = _a.imageSrcProp, imageSrcProp = _c === void 0 ? '' : _c, _d = _a.color, color = _d === void 0 ? '#1e88e5' : _d, _e = _a.imageChanged, imageChanged = _e === void 0 ? function () { } : _e;
    var _f = useState(__assign({}, initialState)), state = _f[0], setState = _f[1];
    var _g = useState(''), imageSrc = _g[0], setImageSrc = _g[1];
    var _h = useState(false), loadImage = _h[0], setLoadImage = _h[1];
    var _j = useState(false), showEditPanel = _j[0], setShowEditPanel = _j[1];
    var _k = useState(labelEn), labels = _k[0], setLabels = _k[1];
    var _l = useState(initialConfig), configuration = _l[0], setConfiguration = _l[1];
    var imagePicker = useRef(null);
    var fileType = useRef('');
    var urlImage = useRef('');
    var uuidFilePicker = Date.now().toString(20);
    var imageName = useRef('download');
    useRef(false);
    useEffect(function () {
        appendLinkIconsToHead();
        processConfig();
    }, [config]);
    useEffect(function () {
        loadImageFromProps();
    }, [imageSrcProp]);
    function loadImageFromProps() {
        return __awaiter(this, void 0, void 0, function () {
            var result, newState, newState;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!imageSrcProp) return [3 /*break*/, 2];
                        return [4 /*yield*/, parseToBase64(imageSrcProp)];
                    case 1:
                        result = _a.sent();
                        newState = result.state;
                        newState.originImageSrc = imageSrcProp;
                        newState.arrayCopiedImages = [
                            {
                                lastImage: result.imageUri,
                                width: newState.maxWidth,
                                height: newState.maxHeight,
                                quality: newState.quality,
                                format: newState.format,
                                originImageSrc: imageSrcProp
                            },
                        ];
                        // console.log("NEW STATE", newState)
                        setImageSrc(result.imageUri);
                        setState(newState);
                        setLoadImage(true);
                        return [3 /*break*/, 3];
                    case 2:
                        newState = __assign({}, state);
                        newState.originImageSrc = null;
                        newState.arrayCopiedImages = [];
                        setLoadImage(false);
                        setImageSrc(null);
                        setState(newState);
                        _a.label = 3;
                    case 3: return [2 /*return*/];
                }
            });
        });
    }
    useEffect(function () {
        imageChanged(imageSrc);
    }, [imageSrc]);
    function processConfig() {
        var dataConf = __assign(__assign({}, configuration), config);
        setConfiguration(dataConf);
        if (config.language != undefined) {
            if (config.language == 'en') {
                setLabels(__assign({}, labelEn));
            }
            if (config.language == 'pt') {
                setLabels(__assign({}, labelPT));
            }
            if (config.language == 'es') {
                setLabels(__assign({}, labelEs));
            }
            if (config.language == 'fr') {
                setLabels(__assign({}, labelFr));
            }
            if (config.language == 'de') {
                setLabels(__assign({}, labelDe));
            }
            if (config.language == 'fa') {
                setLabels(__assign({}, labelFa));
            }
        }
    }
    function appendLinkIconsToHead() {
        var head = document.head;
        var linkIcons = head.querySelector('#ngp-image-picker-icons-id');
        if (linkIcons)
            return;
        var link = document.createElement('link');
        link.href = 'https://fonts.googleapis.com/icon?family=Material+Icons';
        link.rel = 'stylesheet';
        link.id = 'ngp-image-picker-icons-id';
        head.appendChild(link);
    }
    function onUpload(event) {
        var _a;
        event.preventDefault();
        (_a = imagePicker === null || imagePicker === void 0 ? void 0 : imagePicker.current) === null || _a === void 0 ? void 0 : _a.click();
    }
    function handleFileSelect(event) {
        var _a;
        var files = (_a = event.target) === null || _a === void 0 ? void 0 : _a.files;
        if (files) {
            var file = files[0];
            imageName.current = file.name.split('.')[0];
            fileType.current = file.type;
            if (!fileType.current.includes('image'))
                return;
            urlImage.current = "data:".concat(file.type, ";base64,");
            if (file) {
                setState(__assign(__assign({}, state), { format: fileType.current.split('image/')[1] }));
                var reader = new FileReader();
                reader.onload = handleReaderLoaded.bind(this);
                reader.readAsBinaryString(file);
            }
        }
    }
    function handleReaderLoaded(readerEvt) {
        return __awaiter(this, void 0, void 0, function () {
            var binaryString, base64textString, newState, newImageSrc, result, img_1;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        binaryString = readerEvt.target.result;
                        base64textString = btoa(binaryString);
                        newState = __assign({}, state);
                        newImageSrc = urlImage.current + base64textString;
                        newState.originImageSrc = urlImage.current + base64textString;
                        if (!configuration.compressInitial) return [3 /*break*/, 2];
                        newState = __assign(__assign({}, newState), { quality: Math.min(configuration.compressInitial || 92, 100), maintainAspectRatio: true, format: 'jpeg' });
                        return [4 /*yield*/, convertImageUsingCanvas(newState.originImageSrc, false, newState, { getDimFromImage: true })];
                    case 1:
                        result = _a.sent();
                        setState(result.state);
                        setImageSrc(result.imageUri);
                        setLoadImage(true);
                        return [3 /*break*/, 3];
                    case 2:
                        img_1 = document.createElement('img');
                        img_1.src = newImageSrc;
                        img_1.onload = function () {
                            newState.arrayCopiedImages = [];
                            newState.maxHeight = img_1.height;
                            newState.maxWidth = img_1.width;
                            newState.format = fileType.current.split('image/')[1];
                            newState.arrayCopiedImages.push({
                                lastImage: newImageSrc,
                                width: img_1.width,
                                height: img_1.height,
                                quality: newState.quality,
                                format: fileType.current.split('image/')[1],
                                originImageSrc: newState.originImageSrc
                            });
                            setState(newState);
                            setImageSrc(newImageSrc);
                            setLoadImage(true);
                        };
                        _a.label = 3;
                    case 3: return [2 /*return*/];
                }
            });
        });
    }
    var sizeImage = useMemo(function () {
        if (imageSrc && imageSrc.length) {
            return Math.ceil(((3 / 4) * imageSrc.length) / 1024);
        }
        else {
            return '';
        }
    }, [imageSrc]);
    function parseToBase64(imageUrl) {
        var newState = __assign({}, state);
        var types = imageUrl.split('.');
        var type = types[types.length - 1];
        if (type && (type == 'png' || type == 'jpeg' || type == 'webp')) {
            type = type;
        }
        else {
            type = 'jpeg';
        }
        newState.format = type;
        if (config.compressInitial != null) {
            var quality = 1;
            if (config.compressInitial >= 0 && config.compressInitial <= 100) {
                quality = config.compressInitial;
            }
            newState.quality = quality;
        }
        return new Promise(function (resolve, reject) {
            var img = new Image();
            img.crossOrigin = 'Anonymous';
            newState.maxHeight = img.height;
            newState.maxWidth = img.width;
            img.onload = function () {
                var canvas = document.createElement('canvas');
                var ctx = canvas.getContext('2d');
                var ratio = 1.0;
                canvas.width = img.width * ratio;
                canvas.height = img.height * ratio;
                ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                console.log(newState.quality);
                var dataURI = canvas.toDataURL("image/".concat(type), newState.quality / 100);
                return resolve({
                    dataUri: dataURI,
                    width: canvas.width,
                    height: canvas.height
                });
            };
            img.onerror = function (e) {
                return reject(e.message || "Error loading the src = ".concat(imageUrl));
            };
            img.src = imageUrl;
        }).then(function (data) {
            newState = __assign(__assign({}, newState), { maxHeight: data.height, maxWidth: data.width });
            return { imageUri: data.dataUri, state: newState };
        });
    }
    function onOpenEditPanel() {
        setShowEditPanel(true);
    }
    function onCloseEditPanel(data) {
        setShowEditPanel(false);
        if (data) {
            setState(data.state);
            setImageSrc(data.imageSrc);
        }
    }
    function onRemove() {
        setImageSrc(null);
        setLoadImage(false);
        var newState = __assign(__assign({}, state), initialState);
        setState(newState);
        setShowEditPanel(false);
    }
    useEffect(function () {
        var handleKeyDown = function (event) {
            if (event.key === 'Escape') {
                onCloseEditPanel(null);
            }
        };
        document.addEventListener('keydown', handleKeyDown);
        return function () {
            document.removeEventListener('keydown', handleKeyDown);
        };
    }, []);
    return (React.createElement("div", { className: "ReactImagePickerEditor ".concat(config.darkMode ? "dark" : "") },
        !loadImage && (React.createElement("div", { className: 'place-image' },
            React.createElement("div", { className: 'image-holder', style: {
                    width: configuration.width,
                    height: configuration.height,
                    borderRadius: configuration.borderRadius,
                    aspectRatio: configuration.aspectRatio + ''
                } },
                React.createElement("button", { title: labels['Upload a image'], className: 'icon-btn image-upload-btn', onClick: onUpload },
                    React.createElement("span", { className: 'material-icons' }, "add_a_photo")),
                React.createElement("input", { ref: imagePicker, type: 'file', style: { display: 'none' }, id: 'filePicker-' + uuidFilePicker, onChange: handleFileSelect })))),
        loadImage && (React.createElement("div", { className: 'place-image' },
            React.createElement("div", { className: 'image-holder-loaded', style: {
                    width: configuration.width,
                    height: configuration.height,
                    borderRadius: configuration.borderRadius,
                    aspectRatio: configuration.aspectRatio + ''
                } },
                React.createElement("img", { src: imageSrc, alt: 'image-loaded', style: {
                        borderRadius: configuration.borderRadius,
                        objectFit: configuration.objectFit
                    } }),
                React.createElement("div", { className: 'curtain', onClick: onUpload },
                    React.createElement("button", { title: labels['Upload a image'] },
                        React.createElement("span", { className: 'material-icons' }, "add_a_photo"))),
                React.createElement("input", { ref: imagePicker, type: 'file', style: { display: 'none' }, id: 'filePicker-' + uuidFilePicker, onChange: handleFileSelect })),
            sizeImage && (React.createElement("p", { className: 'caption image-caption', style: {
                    color: sizeImage > 120 ? '#f44336' : 'unset',
                    fontWeight: sizeImage > 120 ? '500' : 'unset'
                } },
                "size: ",
                sizeImage,
                "Kb \u00A0 ",
                state.format)),
            React.createElement("div", { style: {
                    flexDirection: 'row',
                    boxSizing: 'border-box',
                    display: 'flex',
                    placeContent: 'flex-start',
                    alignItems: 'flex-start'
                }, className: 'editing-bar-btn' },
                !configuration.hideAddBtn && (React.createElement("button", { className: 'icon-btn', id: 'upload-img', title: labels['Upload a image'], onClick: onUpload },
                    React.createElement("span", { className: 'material-icons' }, "add_a_photo"))),
                !configuration.hideEditBtn && (React.createElement("button", { className: 'icon-btn', id: 'edit-img', title: labels['Open the editor panel'], onClick: onOpenEditPanel },
                    React.createElement("span", { className: 'material-icons' }, "edit"))),
                !configuration.hideDownloadBtn && (React.createElement("a", { id: 'download-img', title: labels['Download the image'], href: imageSrc, download: imageName.current },
                    React.createElement("span", { className: 'material-icons' }, "cloud_download"))),
                !configuration.hideDeleteBtn && (React.createElement("button", { className: 'icon-btn', id: 'delete-img', title: labels['Remove'], onClick: function () { return onRemove(); } },
                    React.createElement("span", { className: 'material-icons' }, "delete")))))),
        showEditPanel && (React.createElement(EditImage, { saveUpdates: onCloseEditPanel, labels: labels, color: color, image: imageSrc, initialState: state, rtl: config.rtl || false, dark: config.darkMode || false }))));
});

export { ReactImagePickerEditor as default };
//# sourceMappingURL=index.modern.js.map
